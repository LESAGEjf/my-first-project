import { __extends } from "tslib";
import { ConnectedPositioningStrategy } from './connected-positioning-strategy';
import { Util } from '../utilities';
var BaseFitPositionStrategy = /** @class */ (function (_super) {
    __extends(BaseFitPositionStrategy, _super);
    function BaseFitPositionStrategy() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    /** @inheritdoc */
    BaseFitPositionStrategy.prototype.position = function (contentElement, size, document, initialCall) {
        var rects = _super.prototype.calculateElementRectangles.call(this, contentElement);
        var connectedFit = {};
        if (initialCall) {
            connectedFit.targetRect = rects.targetRect;
            connectedFit.contentElementRect = rects.elementRect;
            this._initialSettings = this._initialSettings || Object.assign({}, this.settings);
            this.settings = Object.assign({}, this._initialSettings);
            connectedFit.viewPortRect = Util.getViewportRect(document);
            this.updateViewPortFit(connectedFit);
            if (connectedFit.fitHorizontal.back < 0 || connectedFit.fitHorizontal.forward < 0 ||
                connectedFit.fitVertical.back < 0 || connectedFit.fitVertical.forward < 0) {
                this.fitInViewport(contentElement, connectedFit);
            }
        }
        this.setStyle(contentElement, rects.targetRect, rects.elementRect, connectedFit);
    };
    /**
     * Checks if element can fit in viewport and updates provided connectedFit
     * with the result
     * @param connectedFit connectedFit to update
     */
    BaseFitPositionStrategy.prototype.updateViewPortFit = function (connectedFit) {
        connectedFit.left = this.calculateLeft(connectedFit.targetRect, connectedFit.contentElementRect, this.settings.horizontalStartPoint, this.settings.horizontalDirection, connectedFit.horizontalOffset ? connectedFit.horizontalOffset : 0);
        connectedFit.right = connectedFit.left + connectedFit.contentElementRect.width;
        connectedFit.fitHorizontal = {
            back: Math.round(connectedFit.left),
            forward: Math.round(connectedFit.viewPortRect.width - connectedFit.right)
        };
        connectedFit.top = this.calculateTop(connectedFit.targetRect, connectedFit.contentElementRect, this.settings.verticalStartPoint, this.settings.verticalDirection, connectedFit.verticalOffset ? connectedFit.verticalOffset : 0);
        connectedFit.bottom = connectedFit.top + connectedFit.contentElementRect.height;
        connectedFit.fitVertical = {
            back: Math.round(connectedFit.top),
            forward: Math.round(connectedFit.viewPortRect.height - connectedFit.bottom)
        };
    };
    /**
     * Calculates the position of the left border of the element if it gets positioned
     * with provided start point and direction
     * @param targetRect Rectangle of the target where element is attached
     * @param elementRect Rectangle of the element
     * @param startPoint Start point of the target
     * @param direction Direction in which to show the element
     */
    BaseFitPositionStrategy.prototype.calculateLeft = function (targetRect, elementRect, startPoint, direction, offset) {
        return targetRect.right + targetRect.width * startPoint + elementRect.width * direction + offset;
    };
    /**
     * Calculates the position of the top border of the element if it gets positioned
     * with provided position settings related to the target
     * @param targetRect Rectangle of the target where element is attached
     * @param elementRect Rectangle of the element
     * @param startPoint Start point of the target
     * @param direction Direction in which to show the element
     */
    BaseFitPositionStrategy.prototype.calculateTop = function (targetRect, elementRect, startPoint, direction, offset) {
        return targetRect.bottom + targetRect.height * startPoint + elementRect.height * direction + offset;
    };
    return BaseFitPositionStrategy;
}(ConnectedPositioningStrategy));
export { BaseFitPositionStrategy };
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiYmFzZS1maXQtcG9zaXRpb24tc3RyYXRlZ3kuanMiLCJzb3VyY2VSb290Ijoibmc6Ly9pZ25pdGV1aS1hbmd1bGFyLyIsInNvdXJjZXMiOlsibGliL3NlcnZpY2VzL292ZXJsYXkvcG9zaXRpb24vYmFzZS1maXQtcG9zaXRpb24tc3RyYXRlZ3kudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IjtBQUFBLE9BQU8sRUFBRSw0QkFBNEIsRUFBRSxNQUFNLGtDQUFrQyxDQUFDO0FBQ2hGLE9BQU8sRUFBa0UsSUFBSSxFQUErQixNQUFNLGNBQWMsQ0FBQztBQUVqSTtJQUFzRCwyQ0FBNEI7SUFBbEY7O0lBMEZBLENBQUM7SUF0Rkcsa0JBQWtCO0lBQ2xCLDBDQUFRLEdBQVIsVUFBUyxjQUEyQixFQUFFLElBQVUsRUFBRSxRQUFtQixFQUFFLFdBQXFCO1FBQ3hGLElBQU0sS0FBSyxHQUFHLGlCQUFNLDBCQUEwQixZQUFDLGNBQWMsQ0FBQyxDQUFDO1FBQy9ELElBQU0sWUFBWSxHQUFpQixFQUFFLENBQUM7UUFDdEMsSUFBSSxXQUFXLEVBQUU7WUFDYixZQUFZLENBQUMsVUFBVSxHQUFHLEtBQUssQ0FBQyxVQUFVLENBQUM7WUFDM0MsWUFBWSxDQUFDLGtCQUFrQixHQUFHLEtBQUssQ0FBQyxXQUFXLENBQUM7WUFDcEQsSUFBSSxDQUFDLGdCQUFnQixHQUFHLElBQUksQ0FBQyxnQkFBZ0IsSUFBSSxNQUFNLENBQUMsTUFBTSxDQUFDLEVBQUUsRUFBRSxJQUFJLENBQUMsUUFBUSxDQUFDLENBQUM7WUFDbEYsSUFBSSxDQUFDLFFBQVEsR0FBRyxNQUFNLENBQUMsTUFBTSxDQUFDLEVBQUUsRUFBRSxJQUFJLENBQUMsZ0JBQWdCLENBQUMsQ0FBQztZQUN6RCxZQUFZLENBQUMsWUFBWSxHQUFHLElBQUksQ0FBQyxlQUFlLENBQUMsUUFBUSxDQUFDLENBQUM7WUFDM0QsSUFBSSxDQUFDLGlCQUFpQixDQUFDLFlBQVksQ0FBQyxDQUFDO1lBQ3JDLElBQUksWUFBWSxDQUFDLGFB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ZXNDb250ZW50IjpbImltcG9ydCB7IENvbm5lY3RlZFBvc2l0aW9uaW5nU3RyYXRlZ3kgfSBmcm9tICcuL2Nvbm5lY3RlZC1wb3NpdGlvbmluZy1zdHJhdGVneSc7XG5pbXBvcnQgeyBIb3Jpem9udGFsQWxpZ25tZW50LCBWZXJ0aWNhbEFsaWdubWVudCwgUG9zaXRpb25TZXR0aW5ncywgU2l6ZSwgVXRpbCwgQ29ubmVjdGVkRml0LCBPdXRPZlZpZXdQb3J0IH0gZnJvbSAnLi4vdXRpbGl0aWVzJztcblxuZXhwb3J0IGFic3RyYWN0IGNsYXNzIEJhc2VGaXRQb3NpdGlvblN0cmF0ZWd5IGV4dGVuZHMgQ29ubmVjdGVkUG9zaXRpb25pbmdTdHJhdGVneSB7XG4gICAgcHJvdGVjdGVkIF9pbml0aWFsU2l6ZTogU2l6ZTtcbiAgICBwcm90ZWN0ZWQgX2luaXRpYWxTZXR0aW5nczogUG9zaXRpb25TZXR0aW5ncztcblxuICAgIC8qKiBAaW5oZXJpdGRvYyAqL1xuICAgIHBvc2l0aW9uKGNvbnRlbnRFbGVtZW50OiBIVE1MRWxlbWVudCwgc2l6ZTogU2l6ZSwgZG9jdW1lbnQ/OiBEb2N1bWVudCwgaW5pdGlhbENhbGw/OiBib29sZWFuKTogdm9pZCB7XG4gICAgICAgIGNvbnN0IHJlY3RzID0gc3VwZXIuY2FsY3VsYXRlRWxlbWVudFJlY3RhbmdsZXMoY29udGVudEVsZW1lbnQpO1xuICAgICAgICBjb25zdCBjb25uZWN0ZWRGaXQ6IENvbm5lY3RlZEZpdCA9IHt9O1xuICAgICAgICBpZiAoaW5pdGlhbENhbGwpIHtcbiAgICAgICAgICAgIGNvbm5lY3RlZEZpdC50YXJnZXRSZWN0ID0gcmVjdHMudGFyZ2V0UmVjdDtcbiAgICAgICAgICAgIGNvbm5lY3RlZEZpdC5jb250ZW50RWxlbWVudFJlY3QgPSByZWN0cy5lbGVtZW50UmVjdDtcbiAgICAgICAgICAgIHRoaXMuX2luaXRpYWxTZXR0aW5ncyA9IHRoaXMuX2luaXRpYWxTZXR0aW5ncyB8fCBPYmplY3QuYXNzaWduKHt9LCB0aGlzLnNldHRpbmdzKTtcbiAgICAgICAgICAgIHRoaXMuc2V0dGluZ3MgPSBPYmplY3QuYXNzaWduKHt9LCB0aGlzLl9pbml0aWFsU2V0dGluZ3MpO1xuICAgICAgICAgICAgY29ubmVjdGVkRml0LnZpZXdQb3J0UmVjdCA9IFV0aWwuZ2V0Vmlld3BvcnRSZWN0KGRvY3VtZW50KTtcbiAgICAgICAgICAgIHRoaXMudXBkYXRlVmlld1BvcnRGaXQoY29ubmVjdGVkRml0KTtcbiAgICAgICAgICAgIGlmIChjb25uZWN0ZWRGaXQuZml0SG9yaXpvbnRhbC5iYWNrIDwgMCB8fCBjb25uZWN0ZWRGaXQuZml0SG9yaXpvbnRhbC5mb3J3YXJkIDwgMCB8fFxuICAgICAgICAgICAgICAgIGNvbm5lY3RlZEZpdC5maXRWZXJ0aWNhbC5iYWNrIDwgMCB8fCBjb25uZWN0ZWRGaXQuZml0VmVydGljYWwuZm9yd2FyZCA8IDApIHtcbiAgICAgICAgICAgICAgICB0aGlzLmZpdEluVmlld3BvcnQoY29udGVudEVsZW1lbnQsIGNvbm5lY3RlZEZpdCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5zZXRTdHlsZShjb250ZW50RWxlbWVudCwgcmVjdHMudGFyZ2V0UmVjdCwgcmVjdHMuZWxlbWVudFJlY3QsIGNvbm5lY3RlZEZpdCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIGVsZW1lbnQgY2FuIGZpdCBpbiB2aWV3cG9ydCBhbmQgdXBkYXRlcyBwcm92aWRlZCBjb25uZWN0ZWRGaXRcbiAgICAgKiB3aXRoIHRoZSByZXN1bHRcbiAgICAgKiBAcGFyYW0gY29ubmVjdGVkRml0IGNvbm5lY3RlZEZpdCB0byB1cGRhdGVcbiAgICAgKi9cbiAgICBwcm90ZWN0ZWQgdXBkYXRlVmlld1BvcnRGaXQoY29ubmVjdGVkRml0OiBDb25uZWN0ZWRGaXQpIHtcbiAgICAgICAgY29ubmVjdGVkRml0LmxlZnQgPSB0aGlzLmNhbGN1bGF0ZUxlZnQoXG4gICAgICAgICAgICBjb25uZWN0ZWRGaXQudGFyZ2V0UmVjdCxcbiAgICAgICAgICAgIGNvbm5lY3RlZEZpdC5jb250ZW50RWxlbWVudFJlY3QsXG4gICAgICAgICAgICB0aGlzLnNldHRpbmdzLmhvcml6b250YWxTdGFydFBvaW50LFxuICAgICAgICAgICAgdGhpcy5zZXR0aW5ncy5ob3Jpem9udGFsRGlyZWN0aW9uLFxuICAgICAgICAgICAgY29ubmVjdGVkRml0Lmhvcml6b250YWxPZmZzZXQgPyBjb25uZWN0ZWRGaXQuaG9yaXpvbnRhbE9mZnNldCA6IDApO1xuICAgICAgICBjb25uZWN0ZWRGaXQucmlnaHQgPSBjb25uZWN0ZWRGaXQubGVmdCArIGNvbm5lY3RlZEZpdC5jb250ZW50RWxlbWVudFJlY3Qud2lkdGg7XG4gICAgICAgIGNvbm5lY3RlZEZpdC5maXRIb3Jpem9udGFsID0ge1xuICAgICAgICAgICAgICAgIGJhY2s6IE1hdGgucm91bmQoY29ubmVjdGVkRml0LmxlZnQpLFxuICAgICAgICAgICAgICAgIGZvcndhcmQ6IE1hdGgucm91bmQoY29ubmVjdGVkRml0LnZpZXdQb3J0UmVjdC53aWR0aCAtIGNvbm5lY3RlZEZpdC5yaWdodClcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgY29ubmVjdGVkRml0LnRvcCA9IHRoaXMuY2FsY3VsYXRlVG9wKFxuICAgICAgICAgICAgY29ubmVjdGVkRml0LnRhcmdldFJlY3QsXG4gICAgICAgICAgICBjb25uZWN0ZWRGaXQuY29udGVudEVsZW1lbnRSZWN0LFxuICAgICAgICAgICAgdGhpcy5zZXR0aW5ncy52ZXJ0aWNhbFN0YXJ0UG9pbnQsXG4gICAgICAgICAgICB0aGlzLnNldHRpbmdzLnZlcnRpY2FsRGlyZWN0aW9uLFxuICAgICAgICAgICAgY29ubmVjdGVkRml0LnZlcnRpY2FsT2Zmc2V0ID8gY29ubmVjdGVkRml0LnZlcnRpY2FsT2Zmc2V0IDogMCk7XG4gICAgICAgIGNvbm5lY3RlZEZpdC5ib3R0b20gPSBjb25uZWN0ZWRGaXQudG9wICsgY29ubmVjdGVkRml0LmNvbnRlbnRFbGVtZW50UmVjdC5oZWlnaHQ7XG4gICAgICAgIGNvbm5lY3RlZEZpdC5maXRWZXJ0aWNhbCA9IHtcbiAgICAgICAgICAgIGJhY2s6IE1hdGgucm91bmQoY29ubmVjdGVkRml0LnRvcCksXG4gICAgICAgICAgICBmb3J3YXJkOiBNYXRoLnJvdW5kKGNvbm5lY3RlZEZpdC52aWV3UG9ydFJlY3QuaGVpZ2h0IC0gY29ubmVjdGVkRml0LmJvdHRvbSlcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDYWxjdWxhdGVzIHRoZSBwb3NpdGlvbiBvZiB0aGUgbGVmdCBib3JkZXIgb2YgdGhlIGVsZW1lbnQgaWYgaXQgZ2V0cyBwb3NpdGlvbmVkXG4gICAgICogd2l0aCBwcm92aWRlZCBzdGFydCBwb2ludCBhbmQgZGlyZWN0aW9uXG4gICAgICogQHBhcmFtIHRhcmdldFJlY3QgUmVjdGFuZ2xlIG9mIHRoZSB0YXJnZXQgd2hlcmUgZWxlbWVudCBpcyBhdHRhY2hlZFxuICAgICAqIEBwYXJhbSBlbGVtZW50UmVjdCBSZWN0YW5nbGUgb2YgdGhlIGVsZW1lbnRcbiAgICAgKiBAcGFyYW0gc3RhcnRQb2ludCBTdGFydCBwb2ludCBvZiB0aGUgdGFyZ2V0XG4gICAgICogQHBhcmFtIGRpcmVjdGlvbiBEaXJlY3Rpb24gaW4gd2hpY2ggdG8gc2hvdyB0aGUgZWxlbWVudFxuICAgICAqL1xuICAgIHByb3RlY3RlZCBjYWxjdWxhdGVMZWZ0KFxuICAgICAgICB0YXJnZXRSZWN0OiBDbGllbnRSZWN0LCBlbGVtZW50UmVjdDogQ2xpZW50UmVjdCwgc3RhcnRQb2ludDogSG9yaXpvbnRhbEFsaWdubWVudCwgZGlyZWN0aW9uOiBIb3Jpem9udGFsQWxpZ25tZW50LCBvZmZzZXQ/OiBudW1iZXIpOlxuICAgICAgICBudW1iZXIge1xuICAgICAgICByZXR1cm4gdGFyZ2V0UmVjdC5yaWdodCArIHRhcmdldFJlY3Qud2lkdGggKiBzdGFydFBvaW50ICsgZWxlbWVudFJlY3Qud2lkdGggKiBkaXJlY3Rpb24gKyBvZmZzZXQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2FsY3VsYXRlcyB0aGUgcG9zaXRpb24gb2YgdGhlIHRvcCBib3JkZXIgb2YgdGhlIGVsZW1lbnQgaWYgaXQgZ2V0cyBwb3NpdGlvbmVkXG4gICAgICogd2l0aCBwcm92aWRlZCBwb3NpdGlvbiBzZXR0aW5ncyByZWxhdGVkIHRvIHRoZSB0YXJnZXRcbiAgICAgKiBAcGFyYW0gdGFyZ2V0UmVjdCBSZWN0YW5nbGUgb2YgdGhlIHRhcmdldCB3aGVyZSBlbGVtZW50IGlzIGF0dGFjaGVkXG4gICAgICogQHBhcmFtIGVsZW1lbnRSZWN0IFJlY3RhbmdsZSBvZiB0aGUgZWxlbWVudFxuICAgICAqIEBwYXJhbSBzdGFydFBvaW50IFN0YXJ0IHBvaW50IG9mIHRoZSB0YXJnZXRcbiAgICAgKiBAcGFyYW0gZGlyZWN0aW9uIERpcmVjdGlvbiBpbiB3aGljaCB0byBzaG93IHRoZSBlbGVtZW50XG4gICAgICovXG4gICAgcHJvdGVjdGVkIGNhbGN1bGF0ZVRvcChcbiAgICAgICAgdGFyZ2V0UmVjdDogQ2xpZW50UmVjdCwgZWxlbWVudFJlY3Q6IENsaWVudFJlY3QsIHN0YXJ0UG9pbnQ6IFZlcnRpY2FsQWxpZ25tZW50LCBkaXJlY3Rpb246IFZlcnRpY2FsQWxpZ25tZW50LCBvZmZzZXQ/OiBudW1iZXIpOlxuICAgICAgICBudW1iZXIge1xuICAgICAgICByZXR1cm4gdGFyZ2V0UmVjdC5ib3R0b20gKyB0YXJnZXRSZWN0LmhlaWdodCAqIHN0YXJ0UG9pbnQgKyBlbGVtZW50UmVjdC5oZWlnaHQgKiBkaXJlY3Rpb24gKyBvZmZzZXQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRml0cyB0aGUgZWxlbWVudCBpbnRvIHZpZXdwb3J0IGFjY29yZGluZyB0byB0aGUgcG9zaXRpb24gc2V0dGluZ3NcbiAgICAgKiBAcGFyYW0gZWxlbWVudCBlbGVtZW50IHRvIGZpdCBpbiB2aWV3cG9ydFxuICAgICAqIEBwYXJhbSBjb25uZWN0ZWRGaXQgY29ubmVjdGVkRml0IG9iamVjdCBjb250YWluaW5nIGFsbCBuZWNlc3NhcnkgcGFyYW1ldGVyc1xuICAgICAqL1xuICAgIHByb3RlY3RlZCBhYnN0cmFjdCBmaXRJblZpZXdwb3J0KFxuICAgICAgICBlbGVtZW50OiBIVE1MRWxlbWVudCxcbiAgICAgICAgY29ubmVjdGVkRml0OiBDb25uZWN0ZWRGaXQpO1xufVxuXG5cbiJdfQ==